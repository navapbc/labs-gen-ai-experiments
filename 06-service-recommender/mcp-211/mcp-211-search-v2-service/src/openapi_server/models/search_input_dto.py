# coding: utf-8

"""
    Search V2

    Returns service-at-location search results from the 211 National Data Platform's resource repository search index and values that can be used to filter search results.  A common use case for this API is to return a list of abbeviated service at location resources (i.e. search results) using the '/keyword' endpoint, then use values from within the search results to retrieve the details for a selected service-at-location resource using the 'query/service-at-location-details' endpoint on the Query V2 API.  The Search V2 API organizes operations into two categories:  * Search: returns a list of abbreviated service-at-location resources (i.e. search results) from a GET or POST request that can be configured to filter results using operation parameters, such as tags, service areas, taxonomy terms, etc. The Search operations can also be configured to return facets for targeting specific resources in downstream searches, selecting fields used for search, and setting the type of geographic search filter (e.g. filter results using the geographic boundary of a location or distance between the target and the service location). The Search operation supports two methods: GET and POST. The GET method is intended as a basic method compared to the POST method, providing a streamlined approach to searching resources. The POST method, although less simple to implement compared to the GET method, provides a more flexible and configurable approach to managing the request to, and response from the Search operation. Both methods include default values on several query string parameters and request body content fields. Refer to the documentation for more details   * Filters: provides values for parameters used in API operations. As an example, use the 'filters/tags' operation to retrieve a list of values that can be passed as an argument to the Tags filter on the 'search/keyword' POST operation.  HINT: Get started quickly... use the GET search/keyword API operation to retrieve search results, then pass the idServiceAtLocation value from a search result to the 'query/service-at-location-details' operation on the Query V2 API operation to return details on the service at location resource.   The Search API is often used with the Query V2 API and Suggest V2 API to implement use cases. The Query V2 API returns details of specific resources from the NDP resource repository, such as a service at location, service, location and organization. As an example, 'search/keyword' operation returns results with the ID for a service-at-location that that can be passed as an argument to the Query V2 API 'query/service-at-location-details' operation to retrieve the details, such as eligibility, hours of operation, etc, of a service-at-location resource. The Suggest V2 API provides type-ahead functionality that returns values for suggested keyword and location terms, scoped to parameter values such as 'dataOwners' and location types to enhance the user search experience and improve/narrow the quality of search results.   See the Query and Suggest API documentation for more details.  

    The version of the OpenAPI document: 1.0
    Contact: support@211.org
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json




from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from openapi_server.models.location_mode_dto import LocationModeDto
from openapi_server.models.location_type_dto import LocationTypeDto
from openapi_server.models.search_filter import SearchFilter
from openapi_server.models.search_mode_dto import SearchModeDto
from openapi_server.models.search_orderby import SearchOrderby
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class SearchInputDto(BaseModel):
    """
    Configures search request (note: header values can overwrite search request input, in some cases). Refer to documentation of input field and headers for more information).
    """ # noqa: E501
    search: Annotated[str, Field(min_length=1, strict=True)] = Field(description="One or more keywords to search the repository. Set SearchMode to 'Any' to match on at least one keyword.   Set SearchMode to 'All' to match on all words. To search on taxonomy term(s), set KeywordIsTaxonomyTerm to true.  To search on taxonomy code(s), set KeywordIsTaxonomyCode to true. For taxonomy code or taxonomy term searches, set SearchMode to 'All'  to require all taxonomy terms be assigned to resources returned with search results. Set SearchMode to 'Any' to require a match on at least  one taxonomy term/code. Wildcards can be used to search resources with a partial taxonomy code (eg. BD*) or partial taxonomy term (eg. Emer*). All resources matching the characters   before * will be returned. As an example, a taxonomy code search for BD\\* will return all resources with a taxonomy code beginning with BD, the taxonomy  code for Food. Using taxonomy code wildcard searches ensures all resources with 'child' taxonomy codes are returned (eg. BD-1800 is a child of BD, and would be returned  with the BD\\* wildcard taxonomy code search). Wilcards can also be used for taxonomy term searches, and will return matches on all taxonomy terms matching on one or more terms located within the full taxonmy term  (eg. Food Pantry can be match on Food and/or Pantry). A match occurs when all characters before the \\* are matched on or more terms with the full taxonomy term. As as example, a wilcard search on Food* will return   resources with taxonomy term(s) that include any word within its taxonomy term(s) beginning with 'Food'. A search for F\\* will return resources with taxonomy term(s) beginning with F).")
    location: Annotated[str, Field(min_length=1, strict=True)] = Field(description="Location to search for resources.Value can be a zip code, city, county, state, country or longitude_latitude pair. There are four patterns for location searching:   near, within, serving, servingOnly. The pattern is contolled by LocationMode. See LocationMode for details on using each pattern. (Notes ==> note 1: latidude and longitude: when using latitude and longitude for location:   longitude_latitude values must be provided as lon:-119.293106_lat:34.28083 and can include up to a maximum of six digits after the decimal. note 2: the search API geocodes locations and may use the geocoded data  within the search logic. to view the geocoded data of the entered location, set the parameter 'resultsAdvanced' to true to return the gecoded 'location' data with the search result).")
    distance: Optional[StrictInt] = Field(default=10, description="Maximum distance from the entered location to the physical address where the resource is availalble (ie. service is delivered).   Set 'OrderByDistance' to true to sort search results from nearest to farthest from enetered location.  Distance is ignored (set by the system to 0) when LocationMode is set to 'Within' because distance is not applicable when searching within a geographic boundary.   Distance is set to 5000, when LocationMode set to 'Serving' or 'ServingOnly' to ensure all resources with assigned with the selected service areas area returned (ie. locations are considered  service areas when LocationMode set to 'Serving' or 'ServingOnly'). As an example, a service (ie. resource) may be physically located in California but have   service areas throughout the country (eg. helplines).")
    search_within_location_type: Optional[LocationTypeDto] = Field(default=None, alias="searchWithinLocationType")
    skip: StrictInt = Field(description="Number of results to skip. Used with Size to page results. Note that the total number of resources that match the search is returned with 'count' in  the search results, if IncludeTotalCount is set to true.")
    size: StrictInt = Field(description="Number of results to be returned. Used with Skip to page results. Note that the total number of resources that match the search is returned with 'count' in  the search results, if IncludeTotalCount is set to true.")
    include_total_count: Optional[StrictBool] = Field(default=True, description="Set to 'true' to include total number of results available for return. If Size is less than value returned by total count,  use Skip to get additional results", alias="includeTotalCount")
    filters: Optional[List[SearchFilter]] = Field(default=None, description="A list of search filters that can be used to control/limit the scope of the search. A search filter has a field and a value. See 'SearchFilter'  for a list of avaialable fields that can be used to filter searches.")
    orderbys: Optional[List[SearchOrderby]] = Field(default=None, description="A list of orderBy items used to sort results. An orderBy item has a field and a value. If OrderByDistance is set to true,  a orderBy item is programmatically added and used to sort results. OrderBy items added to the list will be executed in the order   that they are added to the list, after ordering by distance. As an example, to sort results by organization name in descending order add an orderBy   object to the orderBys array as follows: {\"field\":\"nameOrganization\", \"value\": \"desc\"}")
    facets: Optional[List[StrictStr]] = Field(default=None, description="Facets are fields/values returned with results that can be used to resubmit a search with search filter(s). This feature is used  to implement 'faceted' navigation. Default set to [\"tagsService\", \"taxonomy/taxonomyTermLevel1\", \"taxonomy/taxonomyTermLevel2\", \"address/stateProvince\", \"serviceAreas/valueType\", \"dataOwnerDisplayName\"].  Override the default count and sorting of facet values by appending count and sort to the field (ie. facetField,count:50,sort:value). Sort by 'value' or 'count'. Use sort:-count to sort in ascending order  of count; use sort:count to sort in desceding order of count. Use sort:-value to sort in descending order of value, and sort:value to sort in ascending order of value. (full example: to return 100   serviceAreas/valueType facets, set the field to ==> serviceAreas/valueType,count:100,sort:-value). Default setting is 10 values for each facet, sorted by count in descending order.  Fields are:  * address/city  * address/county  * address/stateProvince  * address/postalCode  * address/country  * taxonomy/TermLevel1  * taxonomy/TermLevel2  * taxonomy/TermLevel3  * taxonomy/TermLevel4          * taxonomy/TermLevel5  * taxonomy/TermLevel6  * taxonomy/target  * taxonomy/code  * serviceAreas/valueType  * serviceAreas/value  * tagsService  * dataOwner  * dataOwnerDisplayName")
    search_fields: Optional[List[StrictStr]] = Field(default=None, description="List of fields that will be searched using keyword(s). Default set to all fields. Fields are:  * nameOrganization  * nameService  * nameLocation  * nameServiceAtLocation  * alternateNamesOrganization  * alternateNamesService  * alternateNamesLocation  * descriptionService  * descriptionOrganization    Other fields available for search, but not included in default search:  * taxonomyTerm  * taxonomyCode  * serviceAreas/value  * serviceAreas/valueType", alias="searchFields")
    select_fields: Optional[List[StrictStr]] = Field(default=None, description="List of fields to return in search results. Default set to all fields. Fields are:  * idServiceAtLocation  * idService  * idOrganization  * idLocation  * nameOrganization  * nameService  * nameLocation  * nameServiceAtLocation  * alternateNamesOrganization  * alternateNamesService  * alternateNamesLocation  * descriptionService  * descriptionOrganization  * address  * serviceAreas  * taxonomy  * tagsService  * dataOwner  * dataOwnerDisplayName    Other fields available for selection, but not returned in default search:  * None. All available fields are returned with default.", alias="selectFields")
    search_mode: Optional[SearchModeDto] = Field(default=None, alias="searchMode")
    location_mode: LocationModeDto = Field(alias="locationMode")
    keyword_is_taxonomy_code: Optional[StrictBool] = Field(default=False, description="Set to false for regular text search. Set to true to search on taxonomy code or taxonomy code with wild card (e.g. BD-1800 or BD-1800*). Wildcard codes return code and any-child codes. Separate multiple codes with comma (eg. BD-1800,LM-200*).", alias="keywordIsTaxonomyCode")
    keyword_is_taxonomy_term: Optional[StrictBool] = Field(default=False, description="Set to false for regular text search. Set to 'true' if keyword is a taxonomy term or taxonomy terms (eg. Food Pantry). Separate multiple terms with comma (Food Pantry,Emergency Shelter). Wildcards cannot be used with terms.", alias="keywordIsTaxonomyTerm")
    order_by_distance: Optional[StrictBool] = Field(default=True, description="Set to true to order results from nearest to farthest from entered location. OrderByDistance can only be used when locactionMode is set to 'Near', otherwise, will be ignored.", alias="orderByDistance")
    results_advanced: Optional[StrictBool] = Field(default=None, description="Set to 'true' to return all search request and result details, including the geocoded location and the request input data (which may have been programatically modified).   Note: this can help users understand restrictions to search requests implemented through policy, including changes applied to parameter and header arguments.", alias="resultsAdvanced")
    __properties: ClassVar[List[str]] = ["search", "location", "distance", "searchWithinLocationType", "skip", "size", "includeTotalCount", "filters", "orderbys", "facets", "searchFields", "selectFields", "searchMode", "locationMode", "keywordIsTaxonomyCode", "keywordIsTaxonomyTerm", "orderByDistance", "resultsAdvanced"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of SearchInputDto from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in filters (list)
        _items = []
        if self.filters:
            for _item in self.filters:
                if _item:
                    _items.append(_item.to_dict())
            _dict['filters'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in orderbys (list)
        _items = []
        if self.orderbys:
            for _item in self.orderbys:
                if _item:
                    _items.append(_item.to_dict())
            _dict['orderbys'] = _items
        # set to None if filters (nullable) is None
        # and model_fields_set contains the field
        if self.filters is None and "filters" in self.model_fields_set:
            _dict['filters'] = None

        # set to None if orderbys (nullable) is None
        # and model_fields_set contains the field
        if self.orderbys is None and "orderbys" in self.model_fields_set:
            _dict['orderbys'] = None

        # set to None if facets (nullable) is None
        # and model_fields_set contains the field
        if self.facets is None and "facets" in self.model_fields_set:
            _dict['facets'] = None

        # set to None if search_fields (nullable) is None
        # and model_fields_set contains the field
        if self.search_fields is None and "search_fields" in self.model_fields_set:
            _dict['searchFields'] = None

        # set to None if select_fields (nullable) is None
        # and model_fields_set contains the field
        if self.select_fields is None and "select_fields" in self.model_fields_set:
            _dict['selectFields'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of SearchInputDto from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "search": obj.get("search"),
            "location": obj.get("location"),
            "distance": obj.get("distance") if obj.get("distance") is not None else 10,
            "searchWithinLocationType": obj.get("searchWithinLocationType"),
            "skip": obj.get("skip") if obj.get("skip") is not None else 0,
            "size": obj.get("size") if obj.get("size") is not None else 10,
            "includeTotalCount": obj.get("includeTotalCount") if obj.get("includeTotalCount") is not None else True,
            "filters": [SearchFilter.from_dict(_item) for _item in obj.get("filters")] if obj.get("filters") is not None else None,
            "orderbys": [SearchOrderby.from_dict(_item) for _item in obj.get("orderbys")] if obj.get("orderbys") is not None else None,
            "facets": obj.get("facets"),
            "searchFields": obj.get("searchFields"),
            "selectFields": obj.get("selectFields"),
            "searchMode": obj.get("searchMode"),
            "locationMode": obj.get("locationMode"),
            "keywordIsTaxonomyCode": obj.get("keywordIsTaxonomyCode") if obj.get("keywordIsTaxonomyCode") is not None else False,
            "keywordIsTaxonomyTerm": obj.get("keywordIsTaxonomyTerm") if obj.get("keywordIsTaxonomyTerm") is not None else False,
            "orderByDistance": obj.get("orderByDistance") if obj.get("orderByDistance") is not None else True,
            "resultsAdvanced": obj.get("resultsAdvanced")
        })
        return _obj


