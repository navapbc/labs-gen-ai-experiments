# coding: utf-8

"""
    Search V2

    Returns service-at-location search results from the 211 National Data Platform's resource repository search index and values that can be used to filter search results.  A common use case for this API is to return a list of abbeviated service at location resources (i.e. search results) using the '/keyword' endpoint, then use values from within the search results to retrieve the details for a selected service-at-location resource using the 'query/service-at-location-details' endpoint on the Query V2 API.  The Search V2 API organizes operations into two categories:  * Search: returns a list of abbreviated service-at-location resources (i.e. search results) from a GET or POST request that can be configured to filter results using operation parameters, such as tags, service areas, taxonomy terms, etc. The Search operations can also be configured to return facets for targeting specific resources in downstream searches, selecting fields used for search, and setting the type of geographic search filter (e.g. filter results using the geographic boundary of a location or distance between the target and the service location). The Search operation supports two methods: GET and POST. The GET method is intended as a basic method compared to the POST method, providing a streamlined approach to searching resources. The POST method, although less simple to implement compared to the GET method, provides a more flexible and configurable approach to managing the request to, and response from the Search operation. Both methods include default values on several query string parameters and request body content fields. Refer to the documentation for more details   * Filters: provides values for parameters used in API operations. As an example, use the 'filters/tags' operation to retrieve a list of values that can be passed as an argument to the Tags filter on the 'search/keyword' POST operation.  HINT: Get started quickly... use the GET search/keyword API operation to retrieve search results, then pass the idServiceAtLocation value from a search result to the 'query/service-at-location-details' operation on the Query V2 API operation to return details on the service at location resource.   The Search API is often used with the Query V2 API and Suggest V2 API to implement use cases. The Query V2 API returns details of specific resources from the NDP resource repository, such as a service at location, service, location and organization. As an example, 'search/keyword' operation returns results with the ID for a service-at-location that that can be passed as an argument to the Query V2 API 'query/service-at-location-details' operation to retrieve the details, such as eligibility, hours of operation, etc, of a service-at-location resource. The Suggest V2 API provides type-ahead functionality that returns values for suggested keyword and location terms, scoped to parameter values such as 'dataOwners' and location types to enhance the user search experience and improve/narrow the quality of search results.   See the Query and Suggest API documentation for more details.  

    The version of the OpenAPI document: 1.0
    Contact: support@211.org
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json




from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_server.models.geography_point import GeographyPoint
from openapi_server.models.search_result_address_dto import SearchResultAddressDto
from openapi_server.models.search_result_service_area_dto import SearchResultServiceAreaDto
from openapi_server.models.search_result_taxonomy_dto import SearchResultTaxonomyDto
try:
    from typing import Self
except ImportError:
    from typing_extensions import Self

class SearchOutputResultDto(BaseModel):
    """
    SearchOutputResultDto
    """ # noqa: E501
    id_service_at_location: Optional[StrictStr] = Field(default=None, description="ID for service-at-location resource", alias="idServiceAtLocation")
    id_organization: Optional[StrictStr] = Field(default=None, description="ID for organization resource", alias="idOrganization")
    id_service: Optional[StrictStr] = Field(default=None, description="ID for service resource", alias="idService")
    id_location: Optional[StrictStr] = Field(default=None, description="ID for location resource", alias="idLocation")
    name_organization: Optional[StrictStr] = Field(default=None, description="Name of the organization", alias="nameOrganization")
    name_service: Optional[StrictStr] = Field(default=None, description="Name of the service", alias="nameService")
    name_location: Optional[StrictStr] = Field(default=None, description="Name of the location", alias="nameLocation")
    name_service_at_location: Optional[StrictStr] = Field(default=None, description="Name of the service-at-location", alias="nameServiceAtLocation")
    alternate_names_organization: Optional[List[StrictStr]] = Field(default=None, description="Alternates names for the organization", alias="alternateNamesOrganization")
    alternate_names_service: Optional[List[StrictStr]] = Field(default=None, description="Alternates names for the service", alias="alternateNamesService")
    alternate_names_location: Optional[List[StrictStr]] = Field(default=None, description="Alternates names for the location", alias="alternateNamesLocation")
    description_organization: Optional[StrictStr] = Field(default=None, description="Description of the organization", alias="descriptionOrganization")
    description_service: Optional[StrictStr] = Field(default=None, description="Description of the service", alias="descriptionService")
    description_service_vector: Optional[List[Union[StrictFloat, StrictInt]]] = Field(default=None, description="Vectorized description of the service", alias="descriptionServiceVector")
    address: Optional[SearchResultAddressDto] = None
    taxonomy: Optional[List[SearchResultTaxonomyDto]] = Field(default=None, description="Taxonomies assigned to the service")
    service_areas: Optional[List[SearchResultServiceAreaDto]] = Field(default=None, description="Areas of service delivery", alias="serviceAreas")
    tags_service: Optional[List[StrictStr]] = Field(default=None, description="Custom tags assigned to the service", alias="tagsService")
    data_owner: Optional[StrictStr] = Field(default=None, description="Official name of the 211 organization that owns/stewards the resource", alias="dataOwner")
    data_owner_display_name: Optional[StrictStr] = Field(default=None, description="Preferred name for public attribution of the resource", alias="dataOwnerDisplayName")
    geo_point: Optional[GeographyPoint] = Field(default=None, alias="geoPoint")
    status: Optional[StrictStr] = Field(default=None, description="Status of the service at location resource (active or inactive)")
    __properties: ClassVar[List[str]] = ["idServiceAtLocation", "idOrganization", "idService", "idLocation", "nameOrganization", "nameService", "nameLocation", "nameServiceAtLocation", "alternateNamesOrganization", "alternateNamesService", "alternateNamesLocation", "descriptionOrganization", "descriptionService", "descriptionServiceVector", "address", "taxonomy", "serviceAreas", "tagsService", "dataOwner", "dataOwnerDisplayName", "geoPoint", "status"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of SearchOutputResultDto from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={
            },
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of address
        if self.address:
            _dict['address'] = self.address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in taxonomy (list)
        _items = []
        if self.taxonomy:
            for _item in self.taxonomy:
                if _item:
                    _items.append(_item.to_dict())
            _dict['taxonomy'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in service_areas (list)
        _items = []
        if self.service_areas:
            for _item in self.service_areas:
                if _item:
                    _items.append(_item.to_dict())
            _dict['serviceAreas'] = _items
        # override the default output from pydantic by calling `to_dict()` of geo_point
        if self.geo_point:
            _dict['geoPoint'] = self.geo_point.to_dict()
        # set to None if id_service_at_location (nullable) is None
        # and model_fields_set contains the field
        if self.id_service_at_location is None and "id_service_at_location" in self.model_fields_set:
            _dict['idServiceAtLocation'] = None

        # set to None if id_organization (nullable) is None
        # and model_fields_set contains the field
        if self.id_organization is None and "id_organization" in self.model_fields_set:
            _dict['idOrganization'] = None

        # set to None if id_service (nullable) is None
        # and model_fields_set contains the field
        if self.id_service is None and "id_service" in self.model_fields_set:
            _dict['idService'] = None

        # set to None if id_location (nullable) is None
        # and model_fields_set contains the field
        if self.id_location is None and "id_location" in self.model_fields_set:
            _dict['idLocation'] = None

        # set to None if name_organization (nullable) is None
        # and model_fields_set contains the field
        if self.name_organization is None and "name_organization" in self.model_fields_set:
            _dict['nameOrganization'] = None

        # set to None if name_service (nullable) is None
        # and model_fields_set contains the field
        if self.name_service is None and "name_service" in self.model_fields_set:
            _dict['nameService'] = None

        # set to None if name_location (nullable) is None
        # and model_fields_set contains the field
        if self.name_location is None and "name_location" in self.model_fields_set:
            _dict['nameLocation'] = None

        # set to None if name_service_at_location (nullable) is None
        # and model_fields_set contains the field
        if self.name_service_at_location is None and "name_service_at_location" in self.model_fields_set:
            _dict['nameServiceAtLocation'] = None

        # set to None if alternate_names_organization (nullable) is None
        # and model_fields_set contains the field
        if self.alternate_names_organization is None and "alternate_names_organization" in self.model_fields_set:
            _dict['alternateNamesOrganization'] = None

        # set to None if alternate_names_service (nullable) is None
        # and model_fields_set contains the field
        if self.alternate_names_service is None and "alternate_names_service" in self.model_fields_set:
            _dict['alternateNamesService'] = None

        # set to None if alternate_names_location (nullable) is None
        # and model_fields_set contains the field
        if self.alternate_names_location is None and "alternate_names_location" in self.model_fields_set:
            _dict['alternateNamesLocation'] = None

        # set to None if description_organization (nullable) is None
        # and model_fields_set contains the field
        if self.description_organization is None and "description_organization" in self.model_fields_set:
            _dict['descriptionOrganization'] = None

        # set to None if description_service (nullable) is None
        # and model_fields_set contains the field
        if self.description_service is None and "description_service" in self.model_fields_set:
            _dict['descriptionService'] = None

        # set to None if description_service_vector (nullable) is None
        # and model_fields_set contains the field
        if self.description_service_vector is None and "description_service_vector" in self.model_fields_set:
            _dict['descriptionServiceVector'] = None

        # set to None if taxonomy (nullable) is None
        # and model_fields_set contains the field
        if self.taxonomy is None and "taxonomy" in self.model_fields_set:
            _dict['taxonomy'] = None

        # set to None if service_areas (nullable) is None
        # and model_fields_set contains the field
        if self.service_areas is None and "service_areas" in self.model_fields_set:
            _dict['serviceAreas'] = None

        # set to None if tags_service (nullable) is None
        # and model_fields_set contains the field
        if self.tags_service is None and "tags_service" in self.model_fields_set:
            _dict['tagsService'] = None

        # set to None if data_owner (nullable) is None
        # and model_fields_set contains the field
        if self.data_owner is None and "data_owner" in self.model_fields_set:
            _dict['dataOwner'] = None

        # set to None if data_owner_display_name (nullable) is None
        # and model_fields_set contains the field
        if self.data_owner_display_name is None and "data_owner_display_name" in self.model_fields_set:
            _dict['dataOwnerDisplayName'] = None

        # set to None if status (nullable) is None
        # and model_fields_set contains the field
        if self.status is None and "status" in self.model_fields_set:
            _dict['status'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of SearchOutputResultDto from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "idServiceAtLocation": obj.get("idServiceAtLocation"),
            "idOrganization": obj.get("idOrganization"),
            "idService": obj.get("idService"),
            "idLocation": obj.get("idLocation"),
            "nameOrganization": obj.get("nameOrganization"),
            "nameService": obj.get("nameService"),
            "nameLocation": obj.get("nameLocation"),
            "nameServiceAtLocation": obj.get("nameServiceAtLocation"),
            "alternateNamesOrganization": obj.get("alternateNamesOrganization"),
            "alternateNamesService": obj.get("alternateNamesService"),
            "alternateNamesLocation": obj.get("alternateNamesLocation"),
            "descriptionOrganization": obj.get("descriptionOrganization"),
            "descriptionService": obj.get("descriptionService"),
            "descriptionServiceVector": obj.get("descriptionServiceVector"),
            "address": SearchResultAddressDto.from_dict(obj.get("address")) if obj.get("address") is not None else None,
            "taxonomy": [SearchResultTaxonomyDto.from_dict(_item) for _item in obj.get("taxonomy")] if obj.get("taxonomy") is not None else None,
            "serviceAreas": [SearchResultServiceAreaDto.from_dict(_item) for _item in obj.get("serviceAreas")] if obj.get("serviceAreas") is not None else None,
            "tagsService": obj.get("tagsService"),
            "dataOwner": obj.get("dataOwner"),
            "dataOwnerDisplayName": obj.get("dataOwnerDisplayName"),
            "geoPoint": GeographyPoint.from_dict(obj.get("geoPoint")) if obj.get("geoPoint") is not None else None,
            "status": obj.get("status")
        })
        return _obj


